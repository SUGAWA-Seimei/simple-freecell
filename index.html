<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>ãƒ•ãƒªãƒ¼ã‚»ãƒ«</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #controls {
      display: flex;
      justify-content: space-between;
    }
    button{
      font-size:"2em";
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body onload="init()">
  <div id="controls">
    <button style="font-size:2em;" onclick="newGame()">æ–°è¦ã‚²ãƒ¼ãƒ </button>
    <button style="font-size:2em;" onclick="undo()">ä¸€æ‰‹æˆ»ã™</button>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ğŸ¨ ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚«ãƒ©ãƒ¼è¨­å®š
    const bgColor = "#0b6623";         // èƒŒæ™¯è‰²ï¼ˆæ·±ç·‘ï¼‰
    const borderColor = "#000000";     // æ ç·šï¼ˆé»’ï¼‰
    const cardBackColor = "#cccccc";   // ã‚«ãƒ¼ãƒ‰èƒŒé¢ï¼ˆã‚°ãƒ¬ãƒ¼ï¼‰
    const cardFrontColor = "#ffffff";  // ã‚«ãƒ¼ãƒ‰è¡¨é¢ï¼ˆç™½ï¼‰
    const blackTextColor = "#000000";  // é»’æ–‡å­—
    const redTextColor = "#ff0000";    // èµ¤æ–‡å­—

    //ã‚­ãƒ£ãƒ³ãƒã‚¹
    let canvas, ctx;

    //æ•°å­—
    const order = ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];

    //ãƒ‰ãƒ©ãƒƒã‚°åˆ¤å®š
    let dragging = false;
    let dragCards = [];
    let dragOrigin = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let dragX = 0;
    let dragY = 0;


    //ç§»å‹•å±¥æ­´
    let moveHistory = [];

    // ã‚«ãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã¨ä½™ç™½
    let cardWidth = 0;
    let cardHeight = 0;
    let padding = 10;

    // ã‚»ãƒ«ã®ä½ç½®
    let freeCells = [];
    let homeCells = [];


    let freeCellContents = [[], [], [], []];
    let homeCellContents = [[], [], [], []];
    let tableauContents = [];

    //å ´æœ­ã®ä½ç½®
    let tableaus = [];
    let tableauSpacingY = 0;
    let fontSize;
//---------------ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«-----------------------

    function init() {
      canvas = document.getElementById("gameCanvas");
      ctx = canvas.getContext("2d");

      canvas.addEventListener("mousedown", startDrag);
      canvas.addEventListener("mousemove", dragMove);
      canvas.addEventListener("mouseup", endDrag);
      canvas.addEventListener("mouseleave", endDrag);

      canvas.addEventListener("touchstart", startDrag);
      canvas.addEventListener("touchmove", e => {
        e.preventDefault();
        dragMove(e)});
      canvas.addEventListener("touchend", endDrag);
      canvas.addEventListener("touchcancel", endDrag);

      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      if(load_game()==false){newGame();}
    }



    //ã‚«ãƒ¼ãƒ‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆç”Ÿæˆ
    function createCard(suit, value) {
      const isRed = suit === "â™¥" || suit === "â™¦";
      return {
        suit: suit,
        value: value,
        text: `${suit}${value}`,
        color: isRed ? redTextColor : blackTextColor
      };
    }



//-----------æ–°è¦ã‚²ãƒ¼ãƒ ---------------------------------------------

    function newGame() {

      if(tableauContents.filter(a=>a.length>0).length){if(confirm("æ–°è¦ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ","æ–°è¦ã‚²ãƒ¼ãƒ ")==false){return;}};
      console.log("æ–°è¦ã‚²ãƒ¼ãƒ é–‹å§‹ï¼");

      // ã‚»ãƒ«åˆæœŸåŒ–
      freeCellContents = [[], [], [], []];
      homeCellContents = [[], [], [], []];
      tableauContents = [];

      // ãƒ‡ãƒƒã‚­ç”Ÿæˆï¼†é…å¸ƒ
      const deck = generateDeck();
      for (let i = 0; i < 8; i++) {
        tableauContents.push([]);
      }
      for (let i = 0; i < deck.length; i++) {
        tableauContents[i % 8].push(deck[i]);
      }

      // å±¥æ­´ãƒªã‚»ãƒƒãƒˆ
      moveHistory = [];

      save_game();

      drawBackground();
      drawCells();

    }

    //ã‚«ãƒ¼ãƒ‰ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œã£ã¦ã‚·ãƒ£ãƒƒãƒ•ãƒ«
    function generateDeck() {
      const suits = ["â™ ", "â™¥", "â™¦", "â™£"];
      const values = order;
      const deck = [];

      for (const suit of suits) {
        for (const value of values) {
          deck.push(createCard(suit, value));
        }
      }

      // ã‚·ãƒ£ãƒƒãƒ•ãƒ«
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }

      return deck;
    }

//-----------------ãƒ‰ãƒ©ãƒƒã‚°--------------------------------------

    function startDrag(e) {

      let x;
      let y;

      if(dragging){endDrag(e);}

      if('offsetX' in e){
        x = e.offsetX;
        y = e.offsetY;
      }else{
        x = event.touches[0].pageX; - gameCanvas.getBoundingClientRect().left;
        y = event.touches[0].pageY - gameCanvas.getBoundingClientRect().top;  
      }

      // ãƒ•ãƒªãƒ¼ã‚»ãƒ«åˆ¤å®š
      for (let i = 0; i < freeCells.length; i++) {
        const cell = freeCells[i];
        const card = freeCellContents[i];
        if (card.length &&
            x >= cell.x && x <= cell.x + cardWidth &&
            y >= cell.y && y <= cell.y + cardHeight) {
          dragging = true;
          dragCards = card.slice(0);
          dragOrigin = { type: "free", index: i };
          dragOffsetX = x - cell.x;
          dragOffsetY = y - cell.y;
          dragX = x;
          dragY = y;
          freeCellContents[i] = []; // ä¸€æ™‚çš„ã«æ¶ˆã™
          drawBackground();
          drawCells();
          return;
        }
      }

      //å ´æœ­åˆ¤å®š
      for (let i = 0; i < tableaus.length; i++) {

        const pile = tableaus[i];
        const cards = tableauContents[i];
        for (let j = cards.length - 1; j >= 0; j--) {
          const cardX = pile.x;
          const cardY = pile.y + j * tableauSpacingY;
          if (x >= cardX && x <= cardX + cardWidth &&
              y >= cardY && y <= cardY + cardHeight) {
            dragging = true;
            dragCards = cards.slice(j);
            dragOrigin = { type: "tableau", index: i, start: j };
            dragOffsetX = x - cardX;
            dragOffsetY = y - cardY;
            dragX = x;
            dragY = y;

            // å…ƒã®æŸã‹ã‚‰ã‚«ãƒ¼ãƒ‰ã‚’ä¸€æ™‚çš„ã«é™¤å»
            tableauContents[i] = cards.slice(0, j);
            drawBackground();
            drawCells();
            return;
          }
        }
      }
    }


    function dragMove(e) {
      if (!dragging) return;

      let x;
      let y;

      if('offsetX' in e){
        x = e.offsetX;
        y = e.offsetY;
      }else{
        x = event.touches[0].pageX; - gameCanvas.getBoundingClientRect().left;
        y = event.touches[0].pageY - gameCanvas.getBoundingClientRect().top;  
      }

      dragX = x;
      dragY = y;

      // å†æç”»ï¼ˆèƒŒæ™¯ï¼‹é€šå¸¸ï¼‹ãƒ‰ãƒ©ãƒƒã‚°ä¸­ï¼‰
      drawBackground();
      drawCells();


    }

    function endDrag(e) {
      if (!dragging) return;

      let x = dragX;
      let y = dragY;

      // ãƒ‰ãƒ­ãƒƒãƒ—å…ˆåˆ¤å®š
      let target = null;

      // ãƒ•ãƒªãƒ¼ã‚»ãƒ«åˆ¤å®š
      for (let i = 0; i < freeCells.length; i++) {
        const cell = freeCells[i];
        if (isOverlapping(x, y, cell)) {
          target = { type: "free", index: i };
          break;
        }
      }

      // ãƒ›ãƒ¼ãƒ ã‚»ãƒ«åˆ¤å®š
      if (!target) {
        for (let i = 0; i < homeCells.length; i++) {
          const cell = homeCells[i];
          if (isOverlapping(x, y, cell)) {
            target = { type: "home", index: i };
            break;
          }
        }
      }

      // å ´æœ­åˆ¤å®š
      if (!target) {
        for (let i = 0; i < tableaus.length; i++) {
          const pile = tableaus[i];
          const cards = tableauContents[i];
          const topY = pile.y + (cards.length > 0 ? (cards.length - 1) * tableauSpacingY : 0);
          if (isOverlapping(x, y, { x: pile.x, y: topY })) {
            target = { type: "tableau", index: i};
            break;
          }
        }
      }

      // ç§»å‹•åˆ¤å®š
      if (target && canDrop(dragCards, target) && isValidSequence(dragCards) && (dragOrigin.type != target.type || dragOrigin.index != target.index)) {
        applyMove(dragCards, dragOrigin, target);
      }else{
        // å…ƒã«æˆ»ã™
        if (dragOrigin.type === "tableau") {
          tableauContents[dragOrigin.index].push(...dragCards);
        } else if (dragOrigin.type === "free") {
          freeCellContents[dragOrigin.index].push(...dragCards);
        } else if (dragOrigin.type === "home") {
          homeCellContents[dragOrigin.index].push(...dragCards);
        }
      }

      // ãƒªã‚»ãƒƒãƒˆ
      dragging = false;
      dragCards = [];
      dragOrigin = null;
      drawBackground();
      drawCells();

      autoSendToHome();
    }
//---------------------------------------------------------


    function isOverlapping(x, y, cell) {
      const overlapX = x >= cell.x && x <= cell.x + cardWidth;
      const overlapY = y >= cell.y && y <= cell.y + cardHeight;
      const overlapArea = overlapX && overlapY;
      return overlapArea;
    }


//-------------------ç§»å‹•åˆ¤å®š--------------------
    //ç§»å‹•å¯èƒ½ã‹
    function canDrop(cards, target) {
      const card = cards[0];

      if (target.type === "free") {
        return freeCellContents[target.index].length==0;
      }

      if (target.type === "home") {
        const top = homeCellContents[target.index];
        if (top.length==0) {
          return card.value === "A";
        } else {
          topCard = top[top.length-1];
          return card.suit === topCard.suit && isNextValue(topCard.value, card.value);
        }
      }

      if (target.type === "tableau") {
        const pile = tableauContents[target.index];
        if (pile.length === 0) return true;

        const top = pile[pile.length - 1];
        const colorDiff = card.color !== top.color;
        const valueMatch = isPrevValue(card.value, top.value);
        return colorDiff && valueMatch;
      }

      return false;
    }

    function isNextValue(a, b) {
      return order.indexOf(b) === order.indexOf(a) + 1;
    }

    function isPrevValue(a, b) {
      return order.indexOf(a) === order.indexOf(b) - 1;
    }


    function applyMove(cards, origin, target) {

      // å±¥æ­´ã«è¨˜éŒ²
      moveHistory.push({
        cards: [...cards],
        from: origin,
        to: target
      });

      // ç§»å‹•å…ˆã«è¿½åŠ 
      if (target.type === "tableau") {
        tableauContents[target.index].push(...cards);
      } else if (target.type === "free") {
        freeCellContents[target.index].push(...cards);
      } else if (target.type === "home") {
        homeCellContents[target.index].push(...cards);
      }

      save_game();
    }

    function isValidSequence(cards) {
      if (cards.length === 0) return false;

      // è‰²é•ã„ã§1ã¤ãšã¤é™é †ã‹ãƒã‚§ãƒƒã‚¯
      for (let i = 0; i < cards.length - 1; i++) {
        const upper = cards[i];
        const lower = cards[i + 1];

        const colorDiff = upper.color !== lower.color;
        const valueStep = isPrevValue(lower.value, upper.value);

        if (!colorDiff || !valueStep) {
          return false;
        }
      }

      // ç§»å‹•å¯èƒ½ãªæœ€å¤§æ•°ã‚’è¨ˆç®—
      const free = freeCellContents.filter(c => c.length==0).length;
      //const emptyTableaus = tableauContents.filter(pile => pile.length === 0).length;
      //const maxMovable = (free + 1) * (emptyTableaus + 1);

      return cards.length <= free+1;
    }


//------------------è‡ªå‹•ç§»å‹•-------------------------------------
    function autoSendToHome() {

      // ãƒ›ãƒ¼ãƒ ã‚»ãƒ«ã®ä¸­ã§ä¸€ç•ªä½ã„å€¤ã‚’æ¢ã™
      let minIndex = Infinity;
      for (const card of homeCellContents) {
        if (card) {
          const idx = order.indexOf(card.value);
          if (idx !== -1 && idx < minIndex) {
            minIndex = idx;
          }
        }
      }

      // ã¾ã ä½•ã‚‚ç½®ã‹ã‚Œã¦ãªã„å ´åˆã¯ -1 â†’ Aã€œ2ã¾ã§è¨±å¯
      const maxAllowedIndex = minIndex === Infinity ? 1 : minIndex + 2;

      let moved = false;

      function canAutoSend(card) {
        const cardIndex = order.indexOf(card.value);
        if (cardIndex === -1 || cardIndex > maxAllowedIndex) return false;

        const homeIndex = findHomeCellIndex(card);
        return canDrop([card], { type: "home", index: homeIndex });
      }

      // ãƒ•ãƒªãƒ¼ã‚»ãƒ«ãƒã‚§ãƒƒã‚¯
      for (let i = 0; i < freeCellContents.length; i++) {
        const card = freeCellContents[i][0];
        if (card && canAutoSend(card)) {
          const homeIndex = findHomeCellIndex(card);
          applyMove(freeCellContents[i].splice(0,1), { type: "free", index: i }, { type: "home", index: homeIndex});
          moved = true;
          //return;
        }
      }

      // å ´æœ­ãƒã‚§ãƒƒã‚¯
      for (let i = 0; i < tableauContents.length; i++) {
        const pile = tableauContents[i];
        if (pile.length === 0) continue;
        const card = pile[pile.length - 1];
        if (canAutoSend(card)) {
          const homeIndex = findHomeCellIndex(card);
          applyMove(pile.splice(pile.length - 1,1), { type: "tableau", index: i, start: pile.length - 1 }, { type: "home", index: homeIndex });
          //return;
          moved = true;
        }
      }

      drawBackground();
      drawCells();

      if (moved) {
        autoSendToHome(); // å†å¸°çš„ã«ç¹°ã‚Šè¿”ã™
      }
    }

    function findHomeCellIndex(fin) {
      for (let i = 0; i < homeCellContents.length; i++) {
        const card = homeCellContents[i];

        if (card.length==0){ if(fin.value=="A") return i;}else{ if(card[0].suit === fin.suit)  return i;}
      }
      return 0; // fallback
    }

//-------------------------æç”»-------------------------------

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight - document.getElementById("controls").offsetHeight;

      calculateCardSize();
      layoutCells();
      drawBackground();
      drawCells();
    }

    function calculateCardSize() {
      if (canvas.width > canvas.height * 6/5) {
        // æ¨ªé•·
        cardHeight = canvas.height / 5;
        cardWidth = cardHeight * 2 / 3;
      } else {
        // ç¸¦é•· or æ­£æ–¹å½¢å¯„ã‚Š
        cardWidth = canvas.width / 9;
        cardHeight = cardWidth * 1.5;
      }
    }

    function layoutCells() {
      freeCells = [];
      homeCells = [];
      tableaus = [];

      if (canvas.width > canvas.height * 1.45) {
        // æ¨ªé•· â†’ ãƒ•ãƒªãƒ¼ã‚»ãƒ«ã¨ãƒ›ãƒ¼ãƒ ã‚»ãƒ«ã‚’ç¸¦ã«é…ç½®
        const spacing = (canvas.height - 2 * padding - 4 * cardHeight) / 3;
        for (let i = 0; i < 4; i++) {
          let y = padding + i * (cardHeight + spacing);
          freeCells.push({ x: padding, y: y });
          homeCells.push({ x: canvas.width - cardWidth - padding, y: y });
        }

        // å ´æœ­ã®é…ç½®ï¼ˆæ¨ªã«ç­‰é–“éš”ï¼‰
        const leftX = padding + cardWidth;
        const rightX = canvas.width - padding - cardWidth;
        const tableauSpacingX = (rightX - leftX - 8 * cardWidth) / 9;
        const tableauY = padding;

        for (let i = 0; i < 8; i++) {
          let x = leftX + tableauSpacingX + i * (cardWidth + tableauSpacingX);
          tableaus.push({ x: x, y: tableauY });
        }

        // ã‚«ãƒ¼ãƒ‰ã®é‡ãªã‚Šé–“éš”ï¼ˆç¸¦ï¼‰
        tableauSpacingY = (canvas.height - 2 * padding - cardHeight) / 17;
      } else {
        // ç¸¦é•· â†’ ãƒ•ãƒªãƒ¼ã‚»ãƒ«ã¨ãƒ›ãƒ¼ãƒ ã‚»ãƒ«ã‚’æ¨ªã«é…ç½®
        const spacing = cardWidth * 0.05;
        for (let i = 0; i < 4; i++) {
          let xFree = padding * 2 + i * (cardWidth + spacing);
          let xHome = canvas.width - (padding * 2 + (4 - i) * (cardWidth + spacing)) + spacing;
          freeCells.push({ x: xFree, y: padding });
          homeCells.push({ x: xHome, y: padding });
        }

        // å ´æœ­ã®é…ç½®ï¼ˆæ¨ªã«ç­‰é–“éš”ï¼‰
        const tableauY = padding + cardHeight + cardWidth / 10;
        const availableWidth = canvas.width - 2 * padding;
        const tableauSpacingX = (availableWidth - 8 * cardWidth) / 9;

        for (let i = 0; i < 8; i++) {
          let x = padding + tableauSpacingX + i * (cardWidth + tableauSpacingX);
          tableaus.push({ x: x, y: tableauY });
        }

        // ã‚«ãƒ¼ãƒ‰ã®é‡ãªã‚Šé–“éš”ï¼ˆç¸¦ï¼‰
        const availableHeight = canvas.height - tableauY - cardHeight- padding * 2;
        tableauSpacingY = availableHeight / 17;
      }

      const maxHeight = cardHeight / 7;
      const maxWidth = cardWidth * 0.9;

      let testSize = 5;
      ctx.font = `${testSize}px sans-serif`;
      let metrics = ctx.measureText("â™ Q0");

      while (metrics.width <= maxWidth && (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent) <= tableauSpacingY*0.95) {
        testSize++;
        ctx.font = `${testSize}px sans-serif`;
        metrics = ctx.measureText("â™ Q0");
      }

      fontSize = testSize-1;
    }



    function drawCells() {
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;

      // ãƒ•ãƒªãƒ¼ã‚»ãƒ«
      for (let i = 0; i < freeCells.length; i++) {
        const cell = freeCells[i];
        const card = freeCellContents[i];
        if (card.length === 0) {
          drawCard(cell.x,cell.y, null);
        } else {
          drawCard(cell.x,cell.y, card[0]);
        }
      }

      // ãƒ›ãƒ¼ãƒ ã‚»ãƒ«
      for (let i = 0; i < homeCells.length; i++) {
        const cell = homeCells[i];
        const card = homeCellContents[i];
        if (card.length === 0) {
          drawCard(cell.x,cell.y, null);
        } else {
          drawCard(cell.x,cell.y, card[card.length-1]);
        }
      }

      // å ´æœ­
      for (let i = 0; i < tableaus.length; i++) {
        const pile = tableaus[i];
        const cards = tableauContents[i] || [];

        if (cards.length === 0) {
          drawCard(pile.x, pile.y, null);
        } else {
          for (let j = 0; j < cards.length; j++) {
            const card = cards[j];
            const y = pile.y + j * tableauSpacingY;
            drawCard(pile.x, y, card);
          }
        }
      }
      
      //ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã®ã‚«ãƒ¼ãƒ‰
      for (let i = 0; i < dragCards.length; i++) {
        const card = dragCards[i];
        const drawX = dragX - dragOffsetX;
        const drawY = dragY - dragOffsetY + i * tableauSpacingY;
        drawCard(drawX, drawY, card);
      }
    }

    //ã‚«ãƒ¼ãƒ‰è‡ªä½“ã®æç”»
    function drawCard(x, y, card) {
      if (!card) {
        // ç©ºã®ã‚«ãƒ¼ãƒ‰æ 
        ctx.fillStyle = bgColor;
        ctx.fillRect(x, y, cardWidth, cardHeight);
        ctx.strokeStyle = borderColor;
        ctx.strokeRect(x, y, cardWidth, cardHeight);
      } else {
        ctx.fillStyle = cardFrontColor;
        ctx.fillRect(x, y, cardWidth, cardHeight);
        ctx.strokeStyle = borderColor;
        ctx.strokeRect(x, y, cardWidth, cardHeight);

        ctx.fillStyle = card.color;
        ctx.font = `${fontSize}px sans-serif`;
        ctx.textBaseline = "top";
        ctx.fillText(card.text, x + 4, y + 4);
      }
    }

    
    function drawBackground() {
      ctx.fillStyle = bgColor;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }



//-------å…ƒã«æˆ»ã™------------------------------------------------------


    function undo() {
      console.log("ä¸€æ‰‹æˆ»ã™ï¼");
      if (moveHistory.length === 0) return;

      const last = moveHistory.pop();
      const { cards, from, to } = last;

      // ç§»å‹•å…ˆã‹ã‚‰å‰Šé™¤
      if (to.type === "tableau") {
        tableauContents[to.index].splice(-cards.length);
      } else if (to.type === "free") {
        freeCellContents[to.index].splice(-cards.length);
      } else if (to.type === "home") {
        homeCellContents[to.index].splice(-cards.length);
      }

      // å…ƒã«æˆ»ã™
      if (from.type === "tableau") {
        tableauContents[from.index].push(...cards);
      } else if (from.type === "free") {
        freeCellContents[from.index].push(...cards);
      } else if (from.type === "home") {
        homeCellContents[from.index].push(...cards);
      }

      drawBackground();
      drawCells();
    }

//----------------ä¿å­˜-èª­è¾¼--------------------

function save_game(){
	tabe_json = JSON.stringify(tableauContents);
	home_json = JSON.stringify(homeCellContents);
	free_json = JSON.stringify(freeCellContents);
	his_json = JSON.stringify(moveHistory);

	localStorage.setItem("scatolo's_simple-freecel",tabe_json + "/" + home_json + "/" + free_json + "/" + his_json);
}

function load_game(){
        g = localStorage.getItem("scatolo's_simple-freecel");
	if(g==null){
		return false;
	}

	og = g.split("/");
	
	tableauContents = JSON.parse(og[0]);
	homeCellContents = JSON.parse(og[1]);
	freeCellContents = JSON.parse(og[2]);
	moveHistory = JSON.parse(og[3]);
        
        drawBackground();
        drawCells();

        return true;
}


  </script>
</body>
</html>
